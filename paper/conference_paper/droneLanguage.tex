\documentclass{sig-alternate-05-2015}

\usepackage{lambda}
\renewcommand{\progfontsize}{\normalsize}

\begin{document}

\setcopyright{acmcopyright}


% \doi{10.475/123_4}
% \isbn{123-4567-24-567/08/06}

\conferenceinfo{IFL '16}{Aug 31--Sept 2, 2016, KU Leuven, Belgium}
% \acmPrice{\$15.00}
% \conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}

\title{MICL: a real-time mixed-initaitive drone language}
\subtitle{[Extended Abstract]}
% \titlenote{A full version of this paper is available as
% \textit{Author's Guide to Preparing ACM SIG Proceedings Using
% \LaTeX$2_\epsilon$\ and BibTeX} at
% \texttt{www.acm.org/eaddress.htm}}}

\numberofauthors{2}
\author{
% 1st. author
\alignauthor
Keeley Abbott\\
\affaddr{School of EECS
\\ Oregon State University \\ Corvallis, OR, USA}\\
\email{abbottk@eecs.oregonstate.edu}
% 2nd. author
\alignauthor
Eric Walkingshaw\\
\affaddr{School of EECS
\\ Oregon State University \\ Corvallis, OR, USA}\\
\email{walkiner@eecs.oregonstate.edu}
}

\maketitle
\begin{abstract}
We present an embedded domain-specific language for programming
semi-autonomous drones, which is based on functional reactive programming and
has direct application in the use of drones as tools in the scientific and
consumer communities. This language facilitates the explanations of
interactions between the system -- represented by the programmer -- and the
human actor by allowing for a flexible flow of control between the two. We use
the facilities of the human actor by providing them the ability to
directly manipulate the course of the drone based on updated information and
user intuitions. At the same time, we limit the need for programmers to
foresee all possible contingencies by providing variability around control
points within the program.
\end{abstract}


%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003120.10003121.10003124.10011751</concept_id>
<concept_desc>Human-centered computing~Collaborative interaction</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003120.10003121.10003122.10003332</concept_id>
<concept_desc>Human-centered computing~User models</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10003120.10003123.10010860.10010911</concept_id>
<concept_desc>Human-centered computing~Participatory design</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
<concept_desc>Software and its engineering~Functional languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011006.10011050.10011054</concept_id>
<concept_desc>Software and its engineering~Command and control languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10010940.10010971.10011679</concept_id>
<concept_desc>Software and its engineering~Real-time systems software</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Human-centered computing~Collaborative interaction}
\ccsdesc[300]{Human-centered computing~User models}
\ccsdesc[300]{Human-centered computing~Participatory design}
\ccsdesc[500]{Software and its engineering~Functional languages}
\ccsdesc[500]{Software and its engineering~Command and control languages}
\ccsdesc[300]{Software and its engineering~Real-time systems software}

\printccsdesc

\keywords{}

\section{Introduction}
\label{sec:intro}
The number of semi-autonomous controlled vehicles and devices entering the
consumer and industrial markets has increased sharply in recent years. They
have become increasingly important research tools in many fields, including
robotics, computer science, and biology in addition to military
applications. The majority of programs written to control these devices and
vehicles are written in low-level languages like \prog{C}, which limits the
amount of abstraction available to the programmers.

Here we present a domain-specific language embedded in Haskell, intended to
lift the level of abstraction available to programmers who intend to not only
utilize the abilities of the control system, but also incorporate human
input. Unlike previous languages, whose primary intent is to describe a
program executed strictly by the system, our language allows for more complex
interplay between the initiatives represented by the system, and the goals
of the users.

The specification of a program written in MICL is a description of the
tasks to be completed by the system, as well as those that require human
intervention or input (as they are seen by the programmer). In addition
MICL provides the human actor the opportunity to interleave or
intersperse their own goals and objectives as well.

% Surveying as well as search and rescue operations contain elements of mundane
% tasks that can be accommodated by a programmer directly in addition to tasks
% that are often more easily and quickly accomplished by a human actor. A survey
% or search grid can be easily laid out in advance, but there are often
% unforeseen complications presented by the terrain, as well as deviations in the
% behavior of the objects or entities being surveyed or sought.

% These complications can be quickly adapted to by a human actor, whereas
% programming for such contingencies could prove tedious and incomplete. By
% placing the facilities of the drone at the disposal of the human actor, while
% at the same time maintaining a record of the prescribed tasks that can be
% autonomously executed allows the system to execute more effectively. The user
% can focus on the less predictable variables presented to the drone during its
% search pattern, and react to the environmental complications that may or could
% not have been anticipated by the programmer.

This allows for more generalized flight control programs that are quickly and
easily adaptable by human actors in the wild. The human user can combine or
alter flight programs as need dictates, while at the same time remaining
disconnected from the processes programmed until the need arises, or
additional information dictates a change.

In this paper we introduce an domain-specific language that is functionally
reactive and allows for the interleaving of human actor directives, with those
supplied by the programmer. It also allows for timed or event based
interventions or triggers for further program execution. This provides a
degree of variability within drone programming that takes into account the
most up-to-date information and directives, while allowing for automation of
the process whenever outside intervention is not necessary.


\section{Motivation}
\label{sec:motivation}
Biological and environmental surveying utilizing drones and other semi-autonomous
controlled vehicles contains elements of mundane tasks that are easily
relegated to systematic evaluation of a program. However, there are tasks
within these routines that benefit from the ability of human actors to quickly
identify visual patterns, and process that data into updated actions or
directives. Unforeseen complications when laying out a search grid presented
by terrain or deviations in the behavior of wildlife being surveyed may
necessitate changes to the survey route in real time.

Human actors have been used to identify visual patterns as well as in aerial
search activities in the form of crowd-sourcing applications
\cite{quinn2011hc}. Often these tasks come in the form of games, or provide
some monetary compensation for the user's time in classifying or searching
images for data. Frameworks for distributing these tasks to the crowd have
also been developed to assist programmers in developing their queries and
honing them through successive collections of data obtained from the crowd
\cite{little2010turkit}.

One difficulty that is often encountered when using crowd-sourcing for the
purposes of surveying or search and rescue, is that the queries often take a
long time to return results. Which can degrade the chances of a successful
outcome, and can result in the use of outdated information when reacting to
data collected from participants. To some extent this can be mitigated with
the use of increased monetary incentives to the crowd participants. In
addition to timing issues, crowd-sourcing applications often treat humans as
monetized data processing labor, and fail to take advantage of the crowd's
facilities beyond visual pattern matching.

In MICL, we allow the human actor to directly interact with and manipulate the
flow of control and the expected outcomes in real time. This provides the
benefit of making new information gathered by the human actor's visual pattern
matching skills more readily available in addition to allowing us to take
advantage of the human actor's skills and knowledge that may supersede that of
the original goals or programming.


\section{Related Work}
\label{sec:related}
There exist languages and libraries within Haskell that deal with compiling or
writing \prog{safe-C} code, such as Ivory \cite{elliot2015ivory}, and Copilot
\cite{pike2010copilot}. Both of these language extensions are designed to be
used with controllers, and compile \prog{safe-C} code from Haskell that can be
run directly on current controller hardware.

Ivory has been used to implement code that can be run directly on Ardupilot
hardware, and has been used to generate over 200,000 lines of code for
SMACCMPilot as well. In addition, this language has been used in Boeing's
STANAG486 program to pilot an unmanned helicopter through real-world
situations \cite{boeing2016auto}. Unfortunately the structure of the language
presented by Ivory can be a bit difficult to decipher at times, and it is
unknown if the design decision to map the language closely with the compiled
code represents an additional difficulty for programmers.

Copilot on the other hand is a runtime system that generates streams of small
constant-space and constant-time \prog{C} programs that implement embedded
monitoring. Because Copilot also generates its own scheduler, there isn't any
need to implement a real-time operating system in conjunction with it.

Where both of these approaches differ from MICL, is in the availability and
representation of interactions between the system and the human actor
executing the program. In MICL we treat these interactions as first-class
citizens, rather than as an afterthought.


\bibliographystyle{abbrv}
\bibliography{droneLanguage}


\end{document}
